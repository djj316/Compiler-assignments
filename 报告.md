# 数据结构课程作业报告

## 封面
- **姓名**：[邹雨翰]
- **学号**：[20238131002]
- **所选数据结构**：基于链表的队列

## 摘要
本报告实现了一种基于链表结构的队列数据结构。通过定义`ListNode`类构建链表节点，`Queue`类封装队列的入队（`enqueue`）、出队（`dequeue`）、获取队首元素（`frontElement`）、判断队列是否为空（`isEmpty`）以及打印队列（`print`）等操作。最后在`Main`类中对队列各项功能进行测试验证。

## 设计与实现

### 类的定义
1. **`ListNode`类**
    - **属性**：
      - `value: Int`：存储节点整数值。
      - `next: ListNode`：指向链表下一节点，构建链式结构。
    - **方法**：
      - `init(v: Int, n: ListNode): ListNode`：初始化节点`value`和`next`，返回自身。
      - `getValue(): Int`：获取节点`value`值。
      - `getNext(): ListNode`：获取节点`next`值（下一个节点）。
      - `setNext(n: ListNode): ListNode`：设置节点`next`，更新后继节点，返回自身。
2. **`Queue`类**
    - **属性**：
      - `front: ListNode`：队首指针，指向队列首节点。
      - `rear: ListNode`：队尾指针，指向队列尾节点。
    - **方法**：
      - `init(): Queue`：初始化队列，队首、队尾指针初始为空。
      - `enqueue(x: Int): Queue`：入队操作，创建新节点，空队列则队首、队尾指向新节点；非空则添加到队尾并更新队尾指针，返回队列自身。
      - `dequeue(): Queue`：出队操作，空队列直接返回；非空则队首指针后移，若仅一个节点则队尾置空，返回队列自身。
      - `frontElement(): Int`：获取队首元素值，空队列返回`0`，否则返回队首节点`value`。
      - `isEmpty(): Bool`：判断队列是否为空，队首指针为空则返回`true`，否则`false`。
      - `print(): Object`：打印队列元素，空队列输出“队空”，否则依次输出元素。
3. **`Main`类**
    - 含`main()`方法，用于测试`Queue`类的初始化、入队、出队、判空及打印等操作。

### 类之间的关系
- `ListNode`与`Queue`为**组合关系**，`Queue`通过`ListNode`实例构建链表实现队列功能。
- `Main`与`Queue`为**使用关系**，`Main`创建`Queue`实例并调用方法测试。

### 核心算法实现逻辑
1. **入队（`enqueue`）**：
   先创建新`ListNode`节点（`value`为入队整数`x`，`next`初始为空）。若队列为空，队首、队尾均指向新节点；若非空，将当前队尾节点`next`指向新节点，更新队尾指针为新节点，完成入队。
2. **出队（`dequeue`）**：
   若队列为空直接返回；若非空，队首指针后移一位。若队列仅一个节点，出队后队尾置空，完成队首元素出队。

### 实现过程中遇到的挑战及解决方案
- **挑战1**：队列空和仅一个元素的边界情况易出现指针操作错误。
  **解决方案**：针对性编写条件判断，入队、出队前先判空；处理单元素队列时，出队后同时置空队尾指针，通过调试确保边界逻辑正确。
- **挑战2**：`COOL`语言中空值（`void`）处理易引发类型错误。
  **解决方案**：涉及指针操作时，用`isvoid`严格判断指针有效性，避免空指针错误。

## 测试与结果

### 测试代码
```cool
main() : Object {
    {
        let q : Queue <- (new Queue).init() in {
            -- 测试isEmpty方法
            out_string("初始队列是否为空: ");
            if q.isEmpty() then
                out_string("是\n")
            else
                out_string("否\n")
            fi;
		
		out_string("进行入队11,22,33\n");
                q.enqueue(11);
                q.enqueue(22);
                q.enqueue(33);
                q.print();

                -- 再次测试isEmpty方法
                out_string("入队后队列是否为空: ");
                if q.isEmpty() then
                    out_string("是\n")
                else
                    out_string("否\n")
                fi;
		
		out_string("进行出队\n");
                q.dequeue();
                q.print();

                out_string("当前队首:");
                out_int(q.frontElement());
                out_string("\n");

                -- 清空队列
                out_string("清空队列\n");
                q.dequeue();
                q.dequeue();
                
                -- 最后测试isEmpty方法
                out_string("清空队列后是否为空: ");
                if q.isEmpty() then
                    out_string("是\n")
                else
                    out_string("否\n")
                fi;
            };
        }
    };
```

### 程序运行最终输出结果
```
初始队列是否为空: 是
进行入队11,22,33
队列元素: 11 22 33 
入队后队列是否为空: 否
进行出队
队列元素: 22 33 
当前队首:22
清空队列
清空队列后是否为空: 是
```

### 测试结果分析
- 初始队列空，`isEmpty`返回“是”，符合预期。
- 入队11、22、33后，打印队列显示元素依次排列，`isEmpty`返回“否”，入队成功。
- 出队后，队列剩22、33，队首为22，符合队首移除逻辑。
- 两次出队后队列空，`isEmpty`返回“是”，出队及空队列处理正确。测试结果证明队列实现无误。

## 结论

### 收获
- 深入理解队列先进先出特性及核心操作逻辑。
- 熟练掌握`COOL`语言中用类和对象实现数据结构的方法，包括类定义、属性方法声明及类间关系构建。
- 提升边界情况处理与代码调试能力，增强程序健壮性。

### 体会
- 数据结构选择与实现对程序效率和功能至关重要，合适结构让程序更高效简洁。
- 编程中细节（如指针、边界条件）至关重要，需耐心细心调试。
- `COOL`语言虽语法简单，也能很好表达数据结构与算法，加深了对其特性和编程风格的熟悉度。

## GitHub链接
[https://github.com/djj316/Compiler-assignments/tree/main]
